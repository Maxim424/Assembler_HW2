# Assembler_HW2

#### Кузнецов Максим Вадимович. БПИ219. Вариант 22

## Задание
Разработать программу, вычисляющую число вхождений различных знаков препинания в заданной ASCII-строке.

### Решение на каждую оценку лежит в папке с соответствующим именем.

## На оценку 6

- Решение на C находится в файле `main.c`
- Ассемблерная программа без рефакторинга находится в файле `main-default.s`
- Отредактированная ассемблерная программа находится в файле `main.s`
- Отредактированная ассемблерная программа с использованием регистров находится в файле `main-optimised.s`
- Максимальный размер строки для ввода: `100000` символов. Если было введено больше символов, в подсчете участвуют только первые `100000` символов.
- Знаками препинания считаются следующие символы: `. , ; : ! ? ( )`
- Используются локальные переменные (а не глобальные) и передача параметров в 2 функции: для вывода результата и для подсчета количества знаков препинания
- Во всех файлах (кроме `main-default.s`) присутствуют подробные комментарии
- Результаты тестовых прогонов одинаковы для всех указанных программ
- Все тесты содержатся в папке tests, несколько примеров будут приведены далее

***
Для преобразования кода на C в ассемблерный код была использована команда:

``gcc -masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions ./task.c -S -o ./task_1.s``

``-masm=intel`` нужен для того, чтобы использовался синтаксис intel

``-fno-asynchronous-unwind-tables`` убирает отладочную информацию

``-fno-jump-tables`` позволяет не использовать таблицы переходов

``-fno-stack-protector`` защищает от "stack overflow attacks"

``-fno-exceptions`` нужен для правильной работы с исключениями

***
Изменения в функции print_result:
- Вместо [rbp-24] используется регистр r13 (это первый аргумент функции)
- Вместо [rbp-32] используется регистр r14 (это второй аргумент функции)
- Вместо [rbp-4] используется регистр r15d (это локальная переменная i)

Изменения в функции calculate:
- Вместо [rbp-24] используется регистр r13 (это первый аргумент функции)
- Вместо [rbp-32] используется регистр r14 (это второй аргумент функции)
- Вместо [rbp-40] используется регистр r8 (это третий аргумент функции)
- Вместо [rbp-44] используется регистр r9d (это четвертый аргумент функции)
- Вместо [rbp-4] используется регистр r15d (это локальная переменная i)
- Вместо [rbp-8] используется регистр r10d (это локальная переменная j)

Изменения в функции main:
- Вместо [rbp-24] используется регистр r13 (это локальная переменная capacity)
- Вместо [rbp-40] используется регистр r14 (для промежуточных вычислений)
- Вместо [rbp-20] используется регистр r15 (это локальная переменная i)
- В некоторых местах функции main указатели на стек не были заменены регистрами, так как все регистры уже использовались для других целей

### Тест 1

input: 
```
Hello, World!
^D
```

output: 

```
Number of occurrences of different punctuation marks in a given ASCII string:
.       0
,       1
;       0
:       0
!       1
?       0
(       0
)       0
```

### Тест 2

input: 
```
void print_result(char symbols[], int values[]) {
    printf("\nNumber of occurrences of different punctuation marks in a given ASCII string:\n");
    for (int i = 0; i < 8; ++i) {
        printf("%c\t%d\n", symbols[i], values[i]);
    }
}
^D
```

output: 

```
Number of occurrences of different punctuation marks in a given ASCII string:
.       0
,       3
;       4
:       1
!       0
?       0
(       4
)       4
```

***
### Сопоставление размеров программы на ассемблере, полученной после компиляции с языка C с модифицированной программой, использующей регистры

- После компиляции с языка C: 200 строк (файл `main-default.c`)
- После модификации с использованием регистров: 191 строка (файл `main-optimised.c`)

В использующей регистры программе комментарии написаны на тех же строках, что и код. Поэтому комментарии не влияют на количество строк. Но при сравнении были убраны пустые строки. Итого получаем, что программа, использующая регистры, не сильно меньше программы, скомпилированной с языка C. Однако после рефакторинга читаемость кода была значительно улучшена.
