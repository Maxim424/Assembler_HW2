# Assembler_HW2

#### Кузнецов Максим Вадимович. БПИ219. Вариант 22

## Задание
Разработать программу, вычисляющую число вхождений различных знаков препинания в заданной ASCII-строке.

### Решение на каждую оценку лежит в папке с соответствующим именем.

## На оценку 6

- Решение на C находится в файле `main.c`
- Ассемблерная программа без рефакторинга находится в файле `main-default.s`
- Отредактированная ассемблерная программа находится в файле `main.s`
- Отредактированная ассемблерная программа с использованием регистров находится в файле `main-optimised.s`
- Максимальный размер строки для ввода: `100000` символов. Если было введено больше символов, в подсчете участвуют только первые `100000` символов.
- Знаками препинания считаются следующие символы: `. , ; : ! ? ( )`
- Используются локальные переменные (а не глобальные) и передача параметров в 2 функции: для вывода результата и для подсчета количества знаков препинания
- Во всех файлах (кроме `main-default.s`) присутствуют подробные комментарии
- Результаты тестовых прогонов одинаковы для всех указанных программ
- Все тесты содержатся в папке tests, несколько примеров будут приведены далее

***
Для преобразования кода на C в ассемблерный код была использована команда:

``gcc -masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions ./task.c -S -o ./task_1.s``

``-masm=intel`` нужен для того, чтобы использовался синтаксис intel

``-fno-asynchronous-unwind-tables`` убирает отладочную информацию

``-fno-jump-tables`` позволяет не использовать таблицы переходов

``-fno-stack-protector`` защищает от "stack overflow attacks"

``-fno-exceptions`` нужен для правильной работы с исключениями

***
Изменения в функции print_result:
- Вместо [rbp-24] используется регистр r13 (это первый аргумент функции)
- Вместо [rbp-32] используется регистр r14 (это второй аргумент функции)
- Вместо [rbp-4] используется регистр r15d (это локальная переменная i)

Изменения в функции calculate:
- Вместо [rbp-24] используется регистр r13 (это первый аргумент функции)
- Вместо [rbp-32] используется регистр r14 (это второй аргумент функции)
- Вместо [rbp-40] используется регистр r8 (это третий аргумент функции)
- Вместо [rbp-44] используется регистр r9d (это четвертый аргумент функции)
- Вместо [rbp-4] используется регистр r15d (это локальная переменная i)
- Вместо [rbp-8] используется регистр r10d (это локальная переменная j)

Изменения в функции main:
- Вместо [rbp-24] используется регистр r13 (это локальная переменная capacity)
- Вместо [rbp-40] используется регистр r14 (для промежуточных вычислений)
- Вместо [rbp-20] используется регистр r15 (это локальная переменная i)
- В некоторых местах функции main указатели на стек не были заменены регистрами, так как все регистры уже использовались для других целей

### Тест 1

input: 
```
Hello, World!
^D
```

output: 

```
Number of occurrences of different punctuation marks in a given ASCII string:
.       0
,       1
;       0
:       0
!       1
?       0
(       0
)       0
```

### Тест 2

input: 
```
void print_result(char symbols[], int values[]) {
    printf("\nNumber of occurrences of different punctuation marks in a given ASCII string:\n");
    for (int i = 0; i < 8; ++i) {
        printf("%c\t%d\n", symbols[i], values[i]);
    }
}
^D
```

output: 

```
Number of occurrences of different punctuation marks in a given ASCII string:
.       0
,       3
;       4
:       1
!       0
?       0
(       4
)       4
```

***
### Сопоставление размеров программы на ассемблере, полученной после компиляции с языка C с модифицированной программой, использующей регистры

- После компиляции с языка C: 200 строк (файл `main-default.c`)
- После модификации с использованием регистров: 191 строка (файл `main-optimised.c`)

В использующей регистры программе комментарии написаны на тех же строках, что и код. Поэтому комментарии не влияют на количество строк. Но при сравнении были убраны пустые строки. Итого получаем, что программа, использующая регистры, не сильно меньше программы, скомпилированной с языка C. Однако после рефакторинга читаемость кода была значительно улучшена.

## На оценку 7
- Программа на C и на ассемблере представлена в виде двух единиц компиляции
- Ввод и вывод возможен с через файлы с использованием аргументов командной строки
- Если файлы не заданы, то программа предлагает ввести строку через консоль
- Создать исполняемый файл можно через команду `make -f makefile`
- Также программа была лучше декомпозирована: теперь ввод из консоли и ввод из файла выделены соответственно в две функции
- В ассемблерной программе программе используются регистры вместо указателей на стек

### Пример запуска программы с использованием аргументов командной строки
`./main tests/test1_input.txt tests/test1_output.txt`

### Формат входных данных
Содержимое файла должно быть такое же, как и при вводе с консоли: однострочный или многострочный текст с символами кодировки ASCII

## На оценку 8
- Добавлена генерация строки. Сгенерированная строка состоит из `100000` символов от `33` до `126` по ASCII таблице
- Чтобы сгенерировать строку, нужно передать один любой аргумент при запуске программы. Например: `./main 1`. Далее будет выведен результат с количеством знаков препинания для этой строки
- Также соблюдены все критерии на оценку 7, то есть программа декомпозирована и разбита на 2 единицы компиляции
- При вводе более двух аргументов командной строки программа выдает ошибку
- Добален секундомер, который выводит в консоль время работы программы в секундах
- Программа выполняет операции со строкой `500000` раз, чтобы на сгенерированной строке она работала более 1 секунды
- Замеры времени выполняются согласно критериям

### Полученные временные данные

На входной строке
```
Hello, World!
^D
```
программа выполнялась `0.000128` секунд.

На сгенерированной входной строке получались результаты `3.147631`, `3.146765` и `3.146824` .
